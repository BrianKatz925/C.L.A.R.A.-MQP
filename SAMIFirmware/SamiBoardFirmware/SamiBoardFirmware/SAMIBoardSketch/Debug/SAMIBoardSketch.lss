
SAMIBoardSketch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  00000a84  00000b18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a84  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000cc  00800126  00800126  00000b3e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b3e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000b70  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002b0  00000000  00000000  00000bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004710  00000000  00000000  00000e60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013fa  00000000  00000000  00005570  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001742  00000000  00000000  0000696a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006d4  00000000  00000000  000080ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002025  00000000  00000000  00008780  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001b3d  00000000  00000000  0000a7a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  0000c2e2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__ctors_end>
   4:	0c 94 9e 03 	jmp	0x73c	; 0x73c <__vector_1>
   8:	0c 94 c5 03 	jmp	0x78a	; 0x78a <__vector_2>
   c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  10:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  14:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  18:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  1c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  20:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  24:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  28:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  2c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  30:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  34:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  38:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  3c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  40:	0c 94 ec 03 	jmp	0x7d8	; 0x7d8 <__vector_16>
  44:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  48:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  4c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  50:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  54:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  58:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  5c:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>
  60:	0c 94 a1 01 	jmp	0x342	; 0x342 <__vector_24>
  64:	0c 94 8a 00 	jmp	0x114	; 0x114 <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	00 08       	sbc	r0, r0
  6c:	00 02       	muls	r16, r16
  6e:	01 00       	.word	0x0001	; ????
  70:	00 03       	mulsu	r16, r16
  72:	04 07       	cpc	r16, r20
	...

0000007c <digital_pin_to_bit_mask_PGM>:
  7c:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
  8c:	04 08 10 20                                         ... 

00000090 <digital_pin_to_port_PGM>:
  90:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
  a0:	03 03 03 03                                         ....

000000a4 <port_to_input_PGM>:
  a4:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

000000ae <port_to_output_PGM>:
  ae:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000000b8 <port_to_mode_PGM>:
  b8:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000000c2 <__ctors_start>:
  c2:	69 03       	fmul	r22, r17

000000c4 <__ctors_end>:
  c4:	11 24       	eor	r1, r1
  c6:	1f be       	out	0x3f, r1	; 63
  c8:	cf ef       	ldi	r28, 0xFF	; 255
  ca:	d8 e0       	ldi	r29, 0x08	; 8
  cc:	de bf       	out	0x3e, r29	; 62
  ce:	cd bf       	out	0x3d, r28	; 61

000000d0 <__do_copy_data>:
  d0:	11 e0       	ldi	r17, 0x01	; 1
  d2:	a0 e0       	ldi	r26, 0x00	; 0
  d4:	b1 e0       	ldi	r27, 0x01	; 1
  d6:	e4 e8       	ldi	r30, 0x84	; 132
  d8:	fa e0       	ldi	r31, 0x0A	; 10
  da:	02 c0       	rjmp	.+4      	; 0xe0 <__do_copy_data+0x10>
  dc:	05 90       	lpm	r0, Z+
  de:	0d 92       	st	X+, r0
  e0:	a6 32       	cpi	r26, 0x26	; 38
  e2:	b1 07       	cpc	r27, r17
  e4:	d9 f7       	brne	.-10     	; 0xdc <__do_copy_data+0xc>

000000e6 <__do_clear_bss>:
  e6:	21 e0       	ldi	r18, 0x01	; 1
  e8:	a6 e2       	ldi	r26, 0x26	; 38
  ea:	b1 e0       	ldi	r27, 0x01	; 1
  ec:	01 c0       	rjmp	.+2      	; 0xf0 <.do_clear_bss_start>

000000ee <.do_clear_bss_loop>:
  ee:	1d 92       	st	X+, r1

000000f0 <.do_clear_bss_start>:
  f0:	a2 3f       	cpi	r26, 0xF2	; 242
  f2:	b2 07       	cpc	r27, r18
  f4:	e1 f7       	brne	.-8      	; 0xee <.do_clear_bss_loop>

000000f6 <__do_global_ctors>:
  f6:	10 e0       	ldi	r17, 0x00	; 0
  f8:	c2 e6       	ldi	r28, 0x62	; 98
  fa:	d0 e0       	ldi	r29, 0x00	; 0
  fc:	04 c0       	rjmp	.+8      	; 0x106 <__do_global_ctors+0x10>
  fe:	21 97       	sbiw	r28, 0x01	; 1
 100:	fe 01       	movw	r30, r28
 102:	0e 94 3a 05 	call	0xa74	; 0xa74 <__tablejump2__>
 106:	c1 36       	cpi	r28, 0x61	; 97
 108:	d1 07       	cpc	r29, r17
 10a:	c9 f7       	brne	.-14     	; 0xfe <__do_global_ctors+0x8>
 10c:	0e 94 6e 03 	call	0x6dc	; 0x6dc <main>
 110:	0c 94 40 05 	jmp	0xa80	; 0xa80 <_exit>

00000114 <__bad_interrupt>:
 114:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000118 <_Z10encoderISRv>:

/************************************************************************/
/* Read the current sensor and act upon reading                         */
/************************************************************************/
int readCurrentSensor() {
	int currentVal = analogRead(CURRENT_IN_PIN);
 118:	cf 93       	push	r28
 11a:	df 93       	push	r29
 11c:	81 e0       	ldi	r24, 0x01	; 1
 11e:	0e 94 11 05 	call	0xa22	; 0xa22 <digitalRead>
 122:	ec 01       	movw	r28, r24
 124:	80 e2       	ldi	r24, 0x20	; 32
 126:	0e 94 11 05 	call	0xa22	; 0xa22 <digitalRead>
 12a:	cc 0f       	add	r28, r28
 12c:	dd 1f       	adc	r29, r29
 12e:	8c 2b       	or	r24, r28
 130:	9d 2b       	or	r25, r29
 132:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
 136:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
 13a:	ee 0f       	add	r30, r30
 13c:	ff 1f       	adc	r31, r31
 13e:	ee 0f       	add	r30, r30
 140:	ff 1f       	adc	r31, r31
 142:	e0 50       	subi	r30, 0x00	; 0
 144:	ff 4f       	sbci	r31, 0xFF	; 255
 146:	e8 0f       	add	r30, r24
 148:	f9 1f       	adc	r31, r25
 14a:	20 81       	ld	r18, Z
 14c:	25 30       	cpi	r18, 0x05	; 5
 14e:	51 f4       	brne	.+20     	; 0x164 <_Z10encoderISRv+0x4c>
 150:	20 91 28 01 	lds	r18, 0x0128	; 0x800128 <errorCount>
 154:	30 91 29 01 	lds	r19, 0x0129	; 0x800129 <errorCount+0x1>
 158:	2f 5f       	subi	r18, 0xFF	; 255
 15a:	3f 4f       	sbci	r19, 0xFF	; 255
 15c:	30 93 29 01 	sts	0x0129, r19	; 0x800129 <errorCount+0x1>
 160:	20 93 28 01 	sts	0x0128, r18	; 0x800128 <errorCount>
 164:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__data_end+0x1>
 168:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__data_end>
 16c:	df 91       	pop	r29
 16e:	cf 91       	pop	r28
 170:	08 95       	ret

00000172 <setup>:
 172:	61 e0       	ldi	r22, 0x01	; 1
 174:	8d e0       	ldi	r24, 0x0D	; 13
 176:	0e 94 a6 04 	call	0x94c	; 0x94c <pinMode>
 17a:	61 e0       	ldi	r22, 0x01	; 1
 17c:	8e e0       	ldi	r24, 0x0E	; 14
 17e:	0e 94 a6 04 	call	0x94c	; 0x94c <pinMode>
 182:	61 e0       	ldi	r22, 0x01	; 1
 184:	89 e0       	ldi	r24, 0x09	; 9
 186:	0e 94 a6 04 	call	0x94c	; 0x94c <pinMode>
 18a:	61 e0       	ldi	r22, 0x01	; 1
 18c:	8a e0       	ldi	r24, 0x0A	; 10
 18e:	0e 94 a6 04 	call	0x94c	; 0x94c <pinMode>
 192:	60 e0       	ldi	r22, 0x00	; 0
 194:	83 e1       	ldi	r24, 0x13	; 19
 196:	0e 94 a6 04 	call	0x94c	; 0x94c <pinMode>
 19a:	41 e0       	ldi	r20, 0x01	; 1
 19c:	50 e0       	ldi	r21, 0x00	; 0
 19e:	6c e8       	ldi	r22, 0x8C	; 140
 1a0:	70 e0       	ldi	r23, 0x00	; 0
 1a2:	80 e2       	ldi	r24, 0x20	; 32
 1a4:	0e 94 7e 03 	call	0x6fc	; 0x6fc <attachInterrupt>
 1a8:	41 e0       	ldi	r20, 0x01	; 1
 1aa:	50 e0       	ldi	r21, 0x00	; 0
 1ac:	6c e8       	ldi	r22, 0x8C	; 140
 1ae:	70 e0       	ldi	r23, 0x00	; 0
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	0c 94 7e 03 	jmp	0x6fc	; 0x6fc <attachInterrupt>

000001b6 <_Z7forwardv>:
	
}


void forward(){
	digitalWrite(INPUT1_PIN, HIGH);
 1b6:	61 e0       	ldi	r22, 0x01	; 1
 1b8:	8d e0       	ldi	r24, 0x0D	; 13
 1ba:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	digitalWrite(INPUT2_PIN, LOW);
 1be:	60 e0       	ldi	r22, 0x00	; 0
 1c0:	8e e0       	ldi	r24, 0x0E	; 14
 1c2:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	digitalWrite(INPUT3_PIN, LOW);
 1c6:	60 e0       	ldi	r22, 0x00	; 0
 1c8:	89 e0       	ldi	r24, 0x09	; 9
 1ca:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	digitalWrite(INPUT4_PIN, LOW);
 1ce:	60 e0       	ldi	r22, 0x00	; 0
 1d0:	8a e0       	ldi	r24, 0x0A	; 10
 1d2:	0c 94 e2 04 	jmp	0x9c4	; 0x9c4 <digitalWrite>

000001d6 <_Z7reversev>:
}

void reverse(){
	digitalWrite(INPUT1_PIN, LOW);
 1d6:	60 e0       	ldi	r22, 0x00	; 0
 1d8:	8d e0       	ldi	r24, 0x0D	; 13
 1da:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	digitalWrite(INPUT2_PIN, LOW);
 1de:	60 e0       	ldi	r22, 0x00	; 0
 1e0:	8e e0       	ldi	r24, 0x0E	; 14
 1e2:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	digitalWrite(INPUT3_PIN, HIGH);
 1e6:	61 e0       	ldi	r22, 0x01	; 1
 1e8:	89 e0       	ldi	r24, 0x09	; 9
 1ea:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	digitalWrite(INPUT4_PIN, LOW);
 1ee:	60 e0       	ldi	r22, 0x00	; 0
 1f0:	8a e0       	ldi	r24, 0x0A	; 10
 1f2:	0c 94 e2 04 	jmp	0x9c4	; 0x9c4 <digitalWrite>

000001f6 <loop>:
  attachInterrupt(Q1_PIN, encoderISR, CHANGE);
  attachInterrupt(Q2_PIN, encoderISR, CHANGE);
  
}

void loop() {
 1f6:	cf 92       	push	r12
 1f8:	df 92       	push	r13
 1fa:	ef 92       	push	r14
 1fc:	ff 92       	push	r15
  int startTime = millis();
 1fe:	0e 94 36 04 	call	0x86c	; 0x86c <millis>
   
  //forward
	while(startTime + 5000 > millis()) {
 202:	68 57       	subi	r22, 0x78	; 120
 204:	7c 4e       	sbci	r23, 0xEC	; 236
 206:	6b 01       	movw	r12, r22
 208:	77 0f       	add	r23, r23
 20a:	ee 08       	sbc	r14, r14
 20c:	ff 08       	sbc	r15, r15
 20e:	0e 94 36 04 	call	0x86c	; 0x86c <millis>
 212:	6c 15       	cp	r22, r12
 214:	7d 05       	cpc	r23, r13
 216:	8e 05       	cpc	r24, r14
 218:	9f 05       	cpc	r25, r15
 21a:	18 f4       	brcc	.+6      	; 0x222 <loop+0x2c>
		forward();
 21c:	0e 94 db 00 	call	0x1b6	; 0x1b6 <_Z7forwardv>

void loop() {
  int startTime = millis();
   
  //forward
	while(startTime + 5000 > millis()) {
 220:	f6 cf       	rjmp	.-20     	; 0x20e <loop+0x18>
		forward();
	}
  startTime = millis();
 222:	0e 94 36 04 	call	0x86c	; 0x86c <millis>
  
  //brake
  while(startTime + 5000 > millis()) {
 226:	68 57       	subi	r22, 0x78	; 120
 228:	7c 4e       	sbci	r23, 0xEC	; 236
 22a:	6b 01       	movw	r12, r22
 22c:	77 0f       	add	r23, r23
 22e:	ee 08       	sbc	r14, r14
 230:	ff 08       	sbc	r15, r15
 232:	0e 94 36 04 	call	0x86c	; 0x86c <millis>
 236:	6c 15       	cp	r22, r12
 238:	7d 05       	cpc	r23, r13
 23a:	8e 05       	cpc	r24, r14
 23c:	9f 05       	cpc	r25, r15
 23e:	88 f4       	brcc	.+34     	; 0x262 <loop+0x6c>
	  digitalWrite(INPUT1_PIN, LOW);
 240:	60 e0       	ldi	r22, 0x00	; 0
 242:	8d e0       	ldi	r24, 0x0D	; 13
 244:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	  digitalWrite(INPUT2_PIN, HIGH);
 248:	61 e0       	ldi	r22, 0x01	; 1
 24a:	8e e0       	ldi	r24, 0x0E	; 14
 24c:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	  digitalWrite(INPUT3_PIN, LOW);
 250:	60 e0       	ldi	r22, 0x00	; 0
 252:	89 e0       	ldi	r24, 0x09	; 9
 254:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	  digitalWrite(INPUT4_PIN, LOW);
 258:	60 e0       	ldi	r22, 0x00	; 0
 25a:	8a e0       	ldi	r24, 0x0A	; 10
 25c:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
		forward();
	}
  startTime = millis();
  
  //brake
  while(startTime + 5000 > millis()) {
 260:	e8 cf       	rjmp	.-48     	; 0x232 <loop+0x3c>
	  digitalWrite(INPUT1_PIN, LOW);
	  digitalWrite(INPUT2_PIN, HIGH);
	  digitalWrite(INPUT3_PIN, LOW);
	  digitalWrite(INPUT4_PIN, LOW);
  }
  startTime = millis();
 262:	0e 94 36 04 	call	0x86c	; 0x86c <millis>
  
  //reverse
	while(startTime + 5000 > millis()) {
 266:	68 57       	subi	r22, 0x78	; 120
 268:	7c 4e       	sbci	r23, 0xEC	; 236
 26a:	6b 01       	movw	r12, r22
 26c:	77 0f       	add	r23, r23
 26e:	ee 08       	sbc	r14, r14
 270:	ff 08       	sbc	r15, r15
 272:	0e 94 36 04 	call	0x86c	; 0x86c <millis>
 276:	6c 15       	cp	r22, r12
 278:	7d 05       	cpc	r23, r13
 27a:	8e 05       	cpc	r24, r14
 27c:	9f 05       	cpc	r25, r15
 27e:	18 f4       	brcc	.+6      	; 0x286 <loop+0x90>
		reverse();
 280:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <_Z7reversev>
	  digitalWrite(INPUT4_PIN, LOW);
  }
  startTime = millis();
  
  //reverse
	while(startTime + 5000 > millis()) {
 284:	f6 cf       	rjmp	.-20     	; 0x272 <loop+0x7c>
		reverse();
	}
	startTime = millis();
 286:	0e 94 36 04 	call	0x86c	; 0x86c <millis>
  
    //brake
    while(startTime + 5000 > millis()) {
 28a:	68 57       	subi	r22, 0x78	; 120
 28c:	7c 4e       	sbci	r23, 0xEC	; 236
 28e:	6b 01       	movw	r12, r22
 290:	77 0f       	add	r23, r23
 292:	ee 08       	sbc	r14, r14
 294:	ff 08       	sbc	r15, r15
 296:	0e 94 36 04 	call	0x86c	; 0x86c <millis>
 29a:	6c 15       	cp	r22, r12
 29c:	7d 05       	cpc	r23, r13
 29e:	8e 05       	cpc	r24, r14
 2a0:	9f 05       	cpc	r25, r15
 2a2:	88 f4       	brcc	.+34     	; 0x2c6 <loop+0xd0>
	    digitalWrite(INPUT1_PIN, LOW);
 2a4:	60 e0       	ldi	r22, 0x00	; 0
 2a6:	8d e0       	ldi	r24, 0x0D	; 13
 2a8:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	    digitalWrite(INPUT2_PIN, LOW);
 2ac:	60 e0       	ldi	r22, 0x00	; 0
 2ae:	8e e0       	ldi	r24, 0x0E	; 14
 2b0:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	    digitalWrite(INPUT3_PIN, LOW);
 2b4:	60 e0       	ldi	r22, 0x00	; 0
 2b6:	89 e0       	ldi	r24, 0x09	; 9
 2b8:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
	    digitalWrite(INPUT4_PIN, HIGH);
 2bc:	61 e0       	ldi	r22, 0x01	; 1
 2be:	8a e0       	ldi	r24, 0x0A	; 10
 2c0:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <digitalWrite>
		reverse();
	}
	startTime = millis();
  
    //brake
    while(startTime + 5000 > millis()) {
 2c4:	e8 cf       	rjmp	.-48     	; 0x296 <loop+0xa0>
	    digitalWrite(INPUT3_PIN, LOW);
	    digitalWrite(INPUT4_PIN, HIGH);
    }
    startTime = millis();
  
}
 2c6:	ff 90       	pop	r15
 2c8:	ef 90       	pop	r14
 2ca:	df 90       	pop	r13
 2cc:	cf 90       	pop	r12
	    digitalWrite(INPUT1_PIN, LOW);
	    digitalWrite(INPUT2_PIN, LOW);
	    digitalWrite(INPUT3_PIN, LOW);
	    digitalWrite(INPUT4_PIN, HIGH);
    }
    startTime = millis();
 2ce:	0c 94 36 04 	jmp	0x86c	; 0x86c <millis>

000002d2 <twi_transmit>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
 2d2:	40 91 4c 01 	lds	r20, 0x014C	; 0x80014c <twi_txBufferLength>
 2d6:	26 2f       	mov	r18, r22
 2d8:	30 e0       	ldi	r19, 0x00	; 0
 2da:	24 0f       	add	r18, r20
 2dc:	31 1d       	adc	r19, r1
 2de:	21 32       	cpi	r18, 0x21	; 33
 2e0:	31 05       	cpc	r19, r1
 2e2:	dc f4       	brge	.+54     	; 0x31a <twi_transmit+0x48>
 2e4:	20 91 97 01 	lds	r18, 0x0197	; 0x800197 <twi_state>
 2e8:	24 30       	cpi	r18, 0x04	; 4
 2ea:	c9 f4       	brne	.+50     	; 0x31e <twi_transmit+0x4c>
 2ec:	fc 01       	movw	r30, r24
 2ee:	80 e0       	ldi	r24, 0x00	; 0
 2f0:	90 e0       	ldi	r25, 0x00	; 0
 2f2:	86 17       	cp	r24, r22
 2f4:	58 f4       	brcc	.+22     	; 0x30c <twi_transmit+0x3a>
 2f6:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <twi_txBufferLength>
 2fa:	21 91       	ld	r18, Z+
 2fc:	dc 01       	movw	r26, r24
 2fe:	a2 5b       	subi	r26, 0xB2	; 178
 300:	be 4f       	sbci	r27, 0xFE	; 254
 302:	a3 0f       	add	r26, r19
 304:	b1 1d       	adc	r27, r1
 306:	2c 93       	st	X, r18
 308:	01 96       	adiw	r24, 0x01	; 1
 30a:	f3 cf       	rjmp	.-26     	; 0x2f2 <twi_transmit+0x20>
 30c:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <twi_txBufferLength>
 310:	68 0f       	add	r22, r24
 312:	60 93 4c 01 	sts	0x014C, r22	; 0x80014c <twi_txBufferLength>
 316:	80 e0       	ldi	r24, 0x00	; 0
 318:	08 95       	ret
 31a:	81 e0       	ldi	r24, 0x01	; 1
 31c:	08 95       	ret
 31e:	82 e0       	ldi	r24, 0x02	; 2
 320:	08 95       	ret

00000322 <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
 322:	85 ed       	ldi	r24, 0xD5	; 213
 324:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
 328:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 32c:	84 fd       	sbrc	r24, 4
 32e:	fc cf       	rjmp	.-8      	; 0x328 <twi_stop+0x6>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
 330:	10 92 97 01 	sts	0x0197, r1	; 0x800197 <twi_state>
 334:	08 95       	ret

00000336 <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
 336:	85 ec       	ldi	r24, 0xC5	; 197
 338:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>

  // update twi state
  twi_state = TWI_READY;
 33c:	10 92 97 01 	sts	0x0197, r1	; 0x800197 <twi_state>
 340:	08 95       	ret

00000342 <__vector_24>:
}

ISR(TWI_vect)
{
 342:	1f 92       	push	r1
 344:	0f 92       	push	r0
 346:	0f b6       	in	r0, 0x3f	; 63
 348:	0f 92       	push	r0
 34a:	11 24       	eor	r1, r1
 34c:	2f 93       	push	r18
 34e:	3f 93       	push	r19
 350:	4f 93       	push	r20
 352:	5f 93       	push	r21
 354:	6f 93       	push	r22
 356:	7f 93       	push	r23
 358:	8f 93       	push	r24
 35a:	9f 93       	push	r25
 35c:	af 93       	push	r26
 35e:	bf 93       	push	r27
 360:	ef 93       	push	r30
 362:	ff 93       	push	r31
  switch(TW_STATUS){
 364:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
 368:	88 7f       	andi	r24, 0xF8	; 248
 36a:	80 36       	cpi	r24, 0x60	; 96
 36c:	09 f4       	brne	.+2      	; 0x370 <__vector_24+0x2e>
 36e:	9e c0       	rjmp	.+316    	; 0x4ac <__EEPROM_REGION_LENGTH__+0xac>
 370:	78 f5       	brcc	.+94     	; 0x3d0 <__vector_24+0x8e>
 372:	88 32       	cpi	r24, 0x28	; 40
 374:	09 f4       	brne	.+2      	; 0x378 <__vector_24+0x36>
 376:	5d c0       	rjmp	.+186    	; 0x432 <__EEPROM_REGION_LENGTH__+0x32>
 378:	90 f4       	brcc	.+36     	; 0x39e <__vector_24+0x5c>
 37a:	80 31       	cpi	r24, 0x10	; 16
 37c:	09 f4       	brne	.+2      	; 0x380 <__vector_24+0x3e>
 37e:	56 c0       	rjmp	.+172    	; 0x42c <__EEPROM_REGION_LENGTH__+0x2c>
 380:	38 f4       	brcc	.+14     	; 0x390 <__vector_24+0x4e>
 382:	88 23       	and	r24, r24
 384:	09 f4       	brne	.+2      	; 0x388 <__vector_24+0x46>
 386:	f5 c0       	rjmp	.+490    	; 0x572 <__EEPROM_REGION_LENGTH__+0x172>
 388:	88 30       	cpi	r24, 0x08	; 8
 38a:	09 f4       	brne	.+2      	; 0x38e <__vector_24+0x4c>
 38c:	4f c0       	rjmp	.+158    	; 0x42c <__EEPROM_REGION_LENGTH__+0x2c>
 38e:	f5 c0       	rjmp	.+490    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
 390:	88 31       	cpi	r24, 0x18	; 24
 392:	09 f4       	brne	.+2      	; 0x396 <__vector_24+0x54>
 394:	4e c0       	rjmp	.+156    	; 0x432 <__EEPROM_REGION_LENGTH__+0x32>
 396:	80 32       	cpi	r24, 0x20	; 32
 398:	09 f4       	brne	.+2      	; 0x39c <__vector_24+0x5a>
 39a:	5f c0       	rjmp	.+190    	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
 39c:	ee c0       	rjmp	.+476    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
 39e:	80 34       	cpi	r24, 0x40	; 64
 3a0:	09 f4       	brne	.+2      	; 0x3a4 <__vector_24+0x62>
 3a2:	6a c0       	rjmp	.+212    	; 0x478 <__EEPROM_REGION_LENGTH__+0x78>
 3a4:	58 f4       	brcc	.+22     	; 0x3bc <__vector_24+0x7a>
 3a6:	80 33       	cpi	r24, 0x30	; 48
 3a8:	09 f4       	brne	.+2      	; 0x3ac <__vector_24+0x6a>
 3aa:	57 c0       	rjmp	.+174    	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
 3ac:	88 33       	cpi	r24, 0x38	; 56
 3ae:	09 f0       	breq	.+2      	; 0x3b2 <__vector_24+0x70>
 3b0:	e4 c0       	rjmp	.+456    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
 3b2:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <twi_error>
      twi_releaseBus();
 3b6:	0e 94 9b 01 	call	0x336	; 0x336 <twi_releaseBus>
      break;
 3ba:	df c0       	rjmp	.+446    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 3bc:	80 35       	cpi	r24, 0x50	; 80
 3be:	09 f4       	brne	.+2      	; 0x3c2 <__vector_24+0x80>
 3c0:	4f c0       	rjmp	.+158    	; 0x460 <__EEPROM_REGION_LENGTH__+0x60>
 3c2:	88 35       	cpi	r24, 0x58	; 88
 3c4:	09 f4       	brne	.+2      	; 0x3c8 <__vector_24+0x86>
 3c6:	5d c0       	rjmp	.+186    	; 0x482 <__EEPROM_REGION_LENGTH__+0x82>
 3c8:	88 34       	cpi	r24, 0x48	; 72
 3ca:	09 f0       	breq	.+2      	; 0x3ce <__vector_24+0x8c>
 3cc:	d6 c0       	rjmp	.+428    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
 3ce:	d3 c0       	rjmp	.+422    	; 0x576 <__EEPROM_REGION_LENGTH__+0x176>
 3d0:	88 39       	cpi	r24, 0x98	; 152
 3d2:	09 f4       	brne	.+2      	; 0x3d6 <__vector_24+0x94>
 3d4:	c4 c0       	rjmp	.+392    	; 0x55e <__EEPROM_REGION_LENGTH__+0x15e>
 3d6:	a8 f4       	brcc	.+42     	; 0x402 <__EEPROM_REGION_LENGTH__+0x2>
 3d8:	88 37       	cpi	r24, 0x78	; 120
 3da:	09 f4       	brne	.+2      	; 0x3de <__vector_24+0x9c>
 3dc:	67 c0       	rjmp	.+206    	; 0x4ac <__EEPROM_REGION_LENGTH__+0xac>
 3de:	38 f4       	brcc	.+14     	; 0x3ee <__vector_24+0xac>
 3e0:	88 36       	cpi	r24, 0x68	; 104
 3e2:	09 f4       	brne	.+2      	; 0x3e6 <__vector_24+0xa4>
 3e4:	63 c0       	rjmp	.+198    	; 0x4ac <__EEPROM_REGION_LENGTH__+0xac>
 3e6:	80 37       	cpi	r24, 0x70	; 112
 3e8:	09 f4       	brne	.+2      	; 0x3ec <__vector_24+0xaa>
 3ea:	60 c0       	rjmp	.+192    	; 0x4ac <__EEPROM_REGION_LENGTH__+0xac>
 3ec:	c6 c0       	rjmp	.+396    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
 3ee:	88 38       	cpi	r24, 0x88	; 136
 3f0:	09 f4       	brne	.+2      	; 0x3f4 <__vector_24+0xb2>
 3f2:	b5 c0       	rjmp	.+362    	; 0x55e <__EEPROM_REGION_LENGTH__+0x15e>
 3f4:	80 39       	cpi	r24, 0x90	; 144
 3f6:	09 f4       	brne	.+2      	; 0x3fa <__vector_24+0xb8>
 3f8:	5f c0       	rjmp	.+190    	; 0x4b8 <__EEPROM_REGION_LENGTH__+0xb8>
 3fa:	80 38       	cpi	r24, 0x80	; 128
 3fc:	09 f0       	breq	.+2      	; 0x400 <__EEPROM_REGION_LENGTH__>
 3fe:	bd c0       	rjmp	.+378    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
 400:	5b c0       	rjmp	.+182    	; 0x4b8 <__EEPROM_REGION_LENGTH__+0xb8>
 402:	80 3b       	cpi	r24, 0xB0	; 176
 404:	09 f4       	brne	.+2      	; 0x408 <__EEPROM_REGION_LENGTH__+0x8>
 406:	83 c0       	rjmp	.+262    	; 0x50e <__EEPROM_REGION_LENGTH__+0x10e>
 408:	38 f4       	brcc	.+14     	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
 40a:	80 3a       	cpi	r24, 0xA0	; 160
 40c:	09 f4       	brne	.+2      	; 0x410 <__EEPROM_REGION_LENGTH__+0x10>
 40e:	66 c0       	rjmp	.+204    	; 0x4dc <__EEPROM_REGION_LENGTH__+0xdc>
 410:	88 3a       	cpi	r24, 0xA8	; 168
 412:	09 f4       	brne	.+2      	; 0x416 <__EEPROM_REGION_LENGTH__+0x16>
 414:	7c c0       	rjmp	.+248    	; 0x50e <__EEPROM_REGION_LENGTH__+0x10e>
 416:	b1 c0       	rjmp	.+354    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
 418:	80 3c       	cpi	r24, 0xC0	; 192
 41a:	09 f4       	brne	.+2      	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 41c:	a4 c0       	rjmp	.+328    	; 0x566 <__EEPROM_REGION_LENGTH__+0x166>
 41e:	88 3c       	cpi	r24, 0xC8	; 200
 420:	09 f4       	brne	.+2      	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
 422:	a1 c0       	rjmp	.+322    	; 0x566 <__EEPROM_REGION_LENGTH__+0x166>
 424:	88 3b       	cpi	r24, 0xB8	; 184
 426:	09 f4       	brne	.+2      	; 0x42a <__EEPROM_REGION_LENGTH__+0x2a>
 428:	87 c0       	rjmp	.+270    	; 0x538 <__EEPROM_REGION_LENGTH__+0x138>
 42a:	a7 c0       	rjmp	.+334    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
 42c:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <twi_slarw>
 430:	10 c0       	rjmp	.+32     	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
 432:	90 91 6f 01 	lds	r25, 0x016F	; 0x80016f <twi_masterBufferIndex>
 436:	80 91 6e 01 	lds	r24, 0x016E	; 0x80016e <twi_masterBufferLength>
 43a:	98 17       	cp	r25, r24
 43c:	70 f5       	brcc	.+92     	; 0x49a <__EEPROM_REGION_LENGTH__+0x9a>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
 43e:	e0 91 6f 01 	lds	r30, 0x016F	; 0x80016f <twi_masterBufferIndex>
 442:	81 e0       	ldi	r24, 0x01	; 1
 444:	8e 0f       	add	r24, r30
 446:	80 93 6f 01 	sts	0x016F, r24	; 0x80016f <twi_masterBufferIndex>
 44a:	f0 e0       	ldi	r31, 0x00	; 0
 44c:	e0 59       	subi	r30, 0x90	; 144
 44e:	fe 4f       	sbci	r31, 0xFE	; 254
 450:	80 81       	ld	r24, Z
 452:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 456:	85 ec       	ldi	r24, 0xC5	; 197
 458:	83 c0       	rjmp	.+262    	; 0x560 <__EEPROM_REGION_LENGTH__+0x160>
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
 45a:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <twi_error>
 45e:	8b c0       	rjmp	.+278    	; 0x576 <__EEPROM_REGION_LENGTH__+0x176>
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 460:	e0 91 6f 01 	lds	r30, 0x016F	; 0x80016f <twi_masterBufferIndex>
 464:	81 e0       	ldi	r24, 0x01	; 1
 466:	8e 0f       	add	r24, r30
 468:	80 93 6f 01 	sts	0x016F, r24	; 0x80016f <twi_masterBufferIndex>
 46c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
 470:	f0 e0       	ldi	r31, 0x00	; 0
 472:	e0 59       	subi	r30, 0x90	; 144
 474:	fe 4f       	sbci	r31, 0xFE	; 254
 476:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
 478:	90 91 6f 01 	lds	r25, 0x016F	; 0x80016f <twi_masterBufferIndex>
 47c:	80 91 6e 01 	lds	r24, 0x016E	; 0x80016e <twi_masterBufferLength>
 480:	6b c0       	rjmp	.+214    	; 0x558 <__EEPROM_REGION_LENGTH__+0x158>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 482:	e0 91 6f 01 	lds	r30, 0x016F	; 0x80016f <twi_masterBufferIndex>
 486:	81 e0       	ldi	r24, 0x01	; 1
 488:	8e 0f       	add	r24, r30
 48a:	80 93 6f 01 	sts	0x016F, r24	; 0x80016f <twi_masterBufferIndex>
 48e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
 492:	f0 e0       	ldi	r31, 0x00	; 0
 494:	e0 59       	subi	r30, 0x90	; 144
 496:	fe 4f       	sbci	r31, 0xFE	; 254
 498:	80 83       	st	Z, r24
	if (twi_sendStop)
 49a:	80 91 95 01 	lds	r24, 0x0195	; 0x800195 <twi_sendStop>
 49e:	81 11       	cpse	r24, r1
 4a0:	6a c0       	rjmp	.+212    	; 0x576 <__EEPROM_REGION_LENGTH__+0x176>
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
 4a2:	81 e0       	ldi	r24, 0x01	; 1
 4a4:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <twi_inRepStart>
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
 4a8:	84 ea       	ldi	r24, 0xA4	; 164
 4aa:	5e c0       	rjmp	.+188    	; 0x568 <__EEPROM_REGION_LENGTH__+0x168>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
 4ac:	83 e0       	ldi	r24, 0x03	; 3
 4ae:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <twi_state>
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
 4b2:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <twi_rxBufferIndex>
 4b6:	cf cf       	rjmp	.-98     	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
 4b8:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <twi_rxBufferIndex>
 4bc:	80 32       	cpi	r24, 0x20	; 32
 4be:	08 f0       	brcs	.+2      	; 0x4c2 <__EEPROM_REGION_LENGTH__+0xc2>
 4c0:	4e c0       	rjmp	.+156    	; 0x55e <__EEPROM_REGION_LENGTH__+0x15e>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
 4c2:	e0 91 2b 01 	lds	r30, 0x012B	; 0x80012b <twi_rxBufferIndex>
 4c6:	81 e0       	ldi	r24, 0x01	; 1
 4c8:	8e 0f       	add	r24, r30
 4ca:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <twi_rxBufferIndex>
 4ce:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
 4d2:	f0 e0       	ldi	r31, 0x00	; 0
 4d4:	e4 5d       	subi	r30, 0xD4	; 212
 4d6:	fe 4f       	sbci	r31, 0xFE	; 254
 4d8:	80 83       	st	Z, r24
 4da:	bd cf       	rjmp	.-134    	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
 4dc:	0e 94 9b 01 	call	0x336	; 0x336 <twi_releaseBus>
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
 4e0:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <twi_rxBufferIndex>
 4e4:	80 32       	cpi	r24, 0x20	; 32
 4e6:	30 f4       	brcc	.+12     	; 0x4f4 <__EEPROM_REGION_LENGTH__+0xf4>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
 4e8:	e0 91 2b 01 	lds	r30, 0x012B	; 0x80012b <twi_rxBufferIndex>
 4ec:	f0 e0       	ldi	r31, 0x00	; 0
 4ee:	e4 5d       	subi	r30, 0xD4	; 212
 4f0:	fe 4f       	sbci	r31, 0xFE	; 254
 4f2:	10 82       	st	Z, r1
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
 4f4:	60 91 2b 01 	lds	r22, 0x012B	; 0x80012b <twi_rxBufferIndex>
 4f8:	70 e0       	ldi	r23, 0x00	; 0
 4fa:	e0 91 90 01 	lds	r30, 0x0190	; 0x800190 <twi_onSlaveReceive>
 4fe:	f0 91 91 01 	lds	r31, 0x0191	; 0x800191 <twi_onSlaveReceive+0x1>
 502:	8c e2       	ldi	r24, 0x2C	; 44
 504:	91 e0       	ldi	r25, 0x01	; 1
 506:	09 95       	icall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
 508:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <twi_rxBufferIndex>
      break;
 50c:	36 c0       	rjmp	.+108    	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
 50e:	84 e0       	ldi	r24, 0x04	; 4
 510:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <twi_state>
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
 514:	10 92 4d 01 	sts	0x014D, r1	; 0x80014d <twi_txBufferIndex>
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
 518:	10 92 4c 01 	sts	0x014C, r1	; 0x80014c <twi_txBufferLength>
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
 51c:	e0 91 92 01 	lds	r30, 0x0192	; 0x800192 <twi_onSlaveTransmit>
 520:	f0 91 93 01 	lds	r31, 0x0193	; 0x800193 <twi_onSlaveTransmit+0x1>
 524:	09 95       	icall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
 526:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <twi_txBufferLength>
 52a:	81 11       	cpse	r24, r1
 52c:	05 c0       	rjmp	.+10     	; 0x538 <__EEPROM_REGION_LENGTH__+0x138>
        twi_txBufferLength = 1;
 52e:	81 e0       	ldi	r24, 0x01	; 1
 530:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <twi_txBufferLength>
        twi_txBuffer[0] = 0x00;
 534:	10 92 4e 01 	sts	0x014E, r1	; 0x80014e <twi_txBuffer>
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
 538:	e0 91 4d 01 	lds	r30, 0x014D	; 0x80014d <twi_txBufferIndex>
 53c:	81 e0       	ldi	r24, 0x01	; 1
 53e:	8e 0f       	add	r24, r30
 540:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <twi_txBufferIndex>
 544:	f0 e0       	ldi	r31, 0x00	; 0
 546:	e2 5b       	subi	r30, 0xB2	; 178
 548:	fe 4f       	sbci	r31, 0xFE	; 254
 54a:	80 81       	ld	r24, Z
 54c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
 550:	90 91 4d 01 	lds	r25, 0x014D	; 0x80014d <twi_txBufferIndex>
 554:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <twi_txBufferLength>
 558:	98 17       	cp	r25, r24
 55a:	08 f4       	brcc	.+2      	; 0x55e <__EEPROM_REGION_LENGTH__+0x15e>
 55c:	7c cf       	rjmp	.-264    	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
 55e:	85 e8       	ldi	r24, 0x85	; 133
 560:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 564:	0a c0       	rjmp	.+20     	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 566:	85 ec       	ldi	r24, 0xC5	; 197
 568:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
 56c:	10 92 97 01 	sts	0x0197, r1	; 0x800197 <twi_state>
      break;
 570:	04 c0       	rjmp	.+8      	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
 572:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <twi_error>
      twi_stop();
 576:	0e 94 91 01 	call	0x322	; 0x322 <twi_stop>
      break;
  }
}
 57a:	ff 91       	pop	r31
 57c:	ef 91       	pop	r30
 57e:	bf 91       	pop	r27
 580:	af 91       	pop	r26
 582:	9f 91       	pop	r25
 584:	8f 91       	pop	r24
 586:	7f 91       	pop	r23
 588:	6f 91       	pop	r22
 58a:	5f 91       	pop	r21
 58c:	4f 91       	pop	r20
 58e:	3f 91       	pop	r19
 590:	2f 91       	pop	r18
 592:	0f 90       	pop	r0
 594:	0f be       	out	0x3f, r0	; 63
 596:	0f 90       	pop	r0
 598:	1f 90       	pop	r1
 59a:	18 95       	reti

0000059c <_ZN5Print17availableForWriteEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
 59c:	80 e0       	ldi	r24, 0x00	; 0
 59e:	90 e0       	ldi	r25, 0x00	; 0
 5a0:	08 95       	ret

000005a2 <_ZN7TwoWire9availableEv>:
 5a2:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <_ZN7TwoWire14rxBufferLengthE>
 5a6:	90 e0       	ldi	r25, 0x00	; 0
 5a8:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <_ZN7TwoWire13rxBufferIndexE>
 5ac:	82 1b       	sub	r24, r18
 5ae:	91 09       	sbc	r25, r1
 5b0:	08 95       	ret

000005b2 <_ZN7TwoWire4readEv>:
 5b2:	90 91 c8 01 	lds	r25, 0x01C8	; 0x8001c8 <_ZN7TwoWire13rxBufferIndexE>
 5b6:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <_ZN7TwoWire14rxBufferLengthE>
 5ba:	98 17       	cp	r25, r24
 5bc:	50 f4       	brcc	.+20     	; 0x5d2 <_ZN7TwoWire4readEv+0x20>
 5be:	e9 2f       	mov	r30, r25
 5c0:	f0 e0       	ldi	r31, 0x00	; 0
 5c2:	e7 53       	subi	r30, 0x37	; 55
 5c4:	fe 4f       	sbci	r31, 0xFE	; 254
 5c6:	20 81       	ld	r18, Z
 5c8:	30 e0       	ldi	r19, 0x00	; 0
 5ca:	9f 5f       	subi	r25, 0xFF	; 255
 5cc:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <_ZN7TwoWire13rxBufferIndexE>
 5d0:	02 c0       	rjmp	.+4      	; 0x5d6 <_ZN7TwoWire4readEv+0x24>
 5d2:	2f ef       	ldi	r18, 0xFF	; 255
 5d4:	3f ef       	ldi	r19, 0xFF	; 255
 5d6:	c9 01       	movw	r24, r18
 5d8:	08 95       	ret

000005da <_ZN7TwoWire4peekEv>:
 5da:	e0 91 c8 01 	lds	r30, 0x01C8	; 0x8001c8 <_ZN7TwoWire13rxBufferIndexE>
 5de:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <_ZN7TwoWire14rxBufferLengthE>
 5e2:	e8 17       	cp	r30, r24
 5e4:	30 f4       	brcc	.+12     	; 0x5f2 <_ZN7TwoWire4peekEv+0x18>
 5e6:	f0 e0       	ldi	r31, 0x00	; 0
 5e8:	e7 53       	subi	r30, 0x37	; 55
 5ea:	fe 4f       	sbci	r31, 0xFE	; 254
 5ec:	80 81       	ld	r24, Z
 5ee:	90 e0       	ldi	r25, 0x00	; 0
 5f0:	08 95       	ret
 5f2:	8f ef       	ldi	r24, 0xFF	; 255
 5f4:	9f ef       	ldi	r25, 0xFF	; 255
 5f6:	08 95       	ret

000005f8 <_ZN7TwoWire5flushEv>:
 5f8:	08 95       	ret

000005fa <_ZN7TwoWire5writeEPKhj>:
 5fa:	cf 92       	push	r12
 5fc:	df 92       	push	r13
 5fe:	ef 92       	push	r14
 600:	ff 92       	push	r15
 602:	0f 93       	push	r16
 604:	1f 93       	push	r17
 606:	cf 93       	push	r28
 608:	df 93       	push	r29
 60a:	7c 01       	movw	r14, r24
 60c:	cb 01       	movw	r24, r22
 60e:	8a 01       	movw	r16, r20
 610:	20 91 a4 01 	lds	r18, 0x01A4	; 0x8001a4 <_ZN7TwoWire12transmittingE>
 614:	22 23       	and	r18, r18
 616:	89 f0       	breq	.+34     	; 0x63a <_ZN7TwoWire5writeEPKhj+0x40>
 618:	eb 01       	movw	r28, r22
 61a:	6b 01       	movw	r12, r22
 61c:	c4 0e       	add	r12, r20
 61e:	d5 1e       	adc	r13, r21
 620:	cc 15       	cp	r28, r12
 622:	dd 05       	cpc	r29, r13
 624:	69 f0       	breq	.+26     	; 0x640 <_ZN7TwoWire5writeEPKhj+0x46>
 626:	69 91       	ld	r22, Y+
 628:	d7 01       	movw	r26, r14
 62a:	ed 91       	ld	r30, X+
 62c:	fc 91       	ld	r31, X
 62e:	01 90       	ld	r0, Z+
 630:	f0 81       	ld	r31, Z
 632:	e0 2d       	mov	r30, r0
 634:	c7 01       	movw	r24, r14
 636:	09 95       	icall
 638:	f3 cf       	rjmp	.-26     	; 0x620 <_ZN7TwoWire5writeEPKhj+0x26>
 63a:	64 2f       	mov	r22, r20
 63c:	0e 94 69 01 	call	0x2d2	; 0x2d2 <twi_transmit>
 640:	c8 01       	movw	r24, r16
 642:	df 91       	pop	r29
 644:	cf 91       	pop	r28
 646:	1f 91       	pop	r17
 648:	0f 91       	pop	r16
 64a:	ff 90       	pop	r15
 64c:	ef 90       	pop	r14
 64e:	df 90       	pop	r13
 650:	cf 90       	pop	r12
 652:	08 95       	ret

00000654 <_ZN7TwoWire5writeEh>:
 654:	cf 93       	push	r28
 656:	df 93       	push	r29
 658:	1f 92       	push	r1
 65a:	cd b7       	in	r28, 0x3d	; 61
 65c:	de b7       	in	r29, 0x3e	; 62
 65e:	69 83       	std	Y+1, r22	; 0x01
 660:	20 91 a4 01 	lds	r18, 0x01A4	; 0x8001a4 <_ZN7TwoWire12transmittingE>
 664:	22 23       	and	r18, r18
 666:	d1 f0       	breq	.+52     	; 0x69c <_ZN7TwoWire5writeEh+0x48>
 668:	20 91 a5 01 	lds	r18, 0x01A5	; 0x8001a5 <_ZN7TwoWire14txBufferLengthE>
 66c:	20 32       	cpi	r18, 0x20	; 32
 66e:	40 f0       	brcs	.+16     	; 0x680 <_ZN7TwoWire5writeEh+0x2c>
 670:	21 e0       	ldi	r18, 0x01	; 1
 672:	30 e0       	ldi	r19, 0x00	; 0
 674:	fc 01       	movw	r30, r24
 676:	33 83       	std	Z+3, r19	; 0x03
 678:	22 83       	std	Z+2, r18	; 0x02
 67a:	80 e0       	ldi	r24, 0x00	; 0
 67c:	90 e0       	ldi	r25, 0x00	; 0
 67e:	15 c0       	rjmp	.+42     	; 0x6aa <_ZN7TwoWire5writeEh+0x56>
 680:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <_ZN7TwoWire13txBufferIndexE>
 684:	e8 2f       	mov	r30, r24
 686:	f0 e0       	ldi	r31, 0x00	; 0
 688:	e9 55       	subi	r30, 0x59	; 89
 68a:	fe 4f       	sbci	r31, 0xFE	; 254
 68c:	99 81       	ldd	r25, Y+1	; 0x01
 68e:	90 83       	st	Z, r25
 690:	8f 5f       	subi	r24, 0xFF	; 255
 692:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <_ZN7TwoWire13txBufferIndexE>
 696:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <_ZN7TwoWire14txBufferLengthE>
 69a:	05 c0       	rjmp	.+10     	; 0x6a6 <_ZN7TwoWire5writeEh+0x52>
 69c:	61 e0       	ldi	r22, 0x01	; 1
 69e:	ce 01       	movw	r24, r28
 6a0:	01 96       	adiw	r24, 0x01	; 1
 6a2:	0e 94 69 01 	call	0x2d2	; 0x2d2 <twi_transmit>
 6a6:	81 e0       	ldi	r24, 0x01	; 1
 6a8:	90 e0       	ldi	r25, 0x00	; 0
 6aa:	0f 90       	pop	r0
 6ac:	df 91       	pop	r29
 6ae:	cf 91       	pop	r28
 6b0:	08 95       	ret

000006b2 <_ZN7TwoWireC1Ev>:
 6b2:	fc 01       	movw	r30, r24
 6b4:	13 82       	std	Z+3, r1	; 0x03
 6b6:	12 82       	std	Z+2, r1	; 0x02
 6b8:	88 ee       	ldi	r24, 0xE8	; 232
 6ba:	93 e0       	ldi	r25, 0x03	; 3
 6bc:	a0 e0       	ldi	r26, 0x00	; 0
 6be:	b0 e0       	ldi	r27, 0x00	; 0
 6c0:	84 83       	std	Z+4, r24	; 0x04
 6c2:	95 83       	std	Z+5, r25	; 0x05
 6c4:	a6 83       	std	Z+6, r26	; 0x06
 6c6:	b7 83       	std	Z+7, r27	; 0x07
 6c8:	88 e1       	ldi	r24, 0x18	; 24
 6ca:	91 e0       	ldi	r25, 0x01	; 1
 6cc:	91 83       	std	Z+1, r25	; 0x01
 6ce:	80 83       	st	Z, r24
 6d0:	08 95       	ret

000006d2 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
 6d2:	88 e9       	ldi	r24, 0x98	; 152
 6d4:	91 e0       	ldi	r25, 0x01	; 1
 6d6:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <_ZN7TwoWireC1Ev>

000006da <initVariant>:
 6da:	08 95       	ret

000006dc <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
 6dc:	0e 94 42 04 	call	0x884	; 0x884 <init>

	initVariant();
 6e0:	0e 94 6d 03 	call	0x6da	; 0x6da <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
 6e4:	0e 94 b9 00 	call	0x172	; 0x172 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 6e8:	c0 e0       	ldi	r28, 0x00	; 0
 6ea:	d0 e0       	ldi	r29, 0x00	; 0
#endif
	
	setup();
    
	for (;;) {
		loop();
 6ec:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <loop>
		if (serialEventRun) serialEventRun();
 6f0:	20 97       	sbiw	r28, 0x00	; 0
 6f2:	e1 f3       	breq	.-8      	; 0x6ec <main+0x10>
 6f4:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 6f8:	f9 cf       	rjmp	.-14     	; 0x6ec <main+0x10>

000006fa <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
 6fa:	08 95       	ret

000006fc <attachInterrupt>:
 6fc:	82 30       	cpi	r24, 0x02	; 2
 6fe:	e8 f4       	brcc	.+58     	; 0x73a <attachInterrupt+0x3e>
 700:	e8 2f       	mov	r30, r24
 702:	f0 e0       	ldi	r31, 0x00	; 0
 704:	ee 0f       	add	r30, r30
 706:	ff 1f       	adc	r31, r31
 708:	e0 5f       	subi	r30, 0xF0	; 240
 70a:	fe 4f       	sbci	r31, 0xFE	; 254
 70c:	71 83       	std	Z+1, r23	; 0x01
 70e:	60 83       	st	Z, r22
 710:	81 30       	cpi	r24, 0x01	; 1
 712:	41 f0       	breq	.+16     	; 0x724 <attachInterrupt+0x28>
 714:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
 718:	8c 7f       	andi	r24, 0xFC	; 252
 71a:	48 2b       	or	r20, r24
 71c:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
 720:	e8 9a       	sbi	0x1d, 0	; 29
 722:	08 95       	ret
 724:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
 728:	83 7f       	andi	r24, 0xF3	; 243
 72a:	44 0f       	add	r20, r20
 72c:	55 1f       	adc	r21, r21
 72e:	44 0f       	add	r20, r20
 730:	55 1f       	adc	r21, r21
 732:	48 2b       	or	r20, r24
 734:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
 738:	e9 9a       	sbi	0x1d, 1	; 29
 73a:	08 95       	ret

0000073c <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
 73c:	1f 92       	push	r1
 73e:	0f 92       	push	r0
 740:	0f b6       	in	r0, 0x3f	; 63
 742:	0f 92       	push	r0
 744:	11 24       	eor	r1, r1
 746:	2f 93       	push	r18
 748:	3f 93       	push	r19
 74a:	4f 93       	push	r20
 74c:	5f 93       	push	r21
 74e:	6f 93       	push	r22
 750:	7f 93       	push	r23
 752:	8f 93       	push	r24
 754:	9f 93       	push	r25
 756:	af 93       	push	r26
 758:	bf 93       	push	r27
 75a:	ef 93       	push	r30
 75c:	ff 93       	push	r31
 75e:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <intFunc>
 762:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <intFunc+0x1>
 766:	09 95       	icall
 768:	ff 91       	pop	r31
 76a:	ef 91       	pop	r30
 76c:	bf 91       	pop	r27
 76e:	af 91       	pop	r26
 770:	9f 91       	pop	r25
 772:	8f 91       	pop	r24
 774:	7f 91       	pop	r23
 776:	6f 91       	pop	r22
 778:	5f 91       	pop	r21
 77a:	4f 91       	pop	r20
 77c:	3f 91       	pop	r19
 77e:	2f 91       	pop	r18
 780:	0f 90       	pop	r0
 782:	0f be       	out	0x3f, r0	; 63
 784:	0f 90       	pop	r0
 786:	1f 90       	pop	r1
 788:	18 95       	reti

0000078a <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
 78a:	1f 92       	push	r1
 78c:	0f 92       	push	r0
 78e:	0f b6       	in	r0, 0x3f	; 63
 790:	0f 92       	push	r0
 792:	11 24       	eor	r1, r1
 794:	2f 93       	push	r18
 796:	3f 93       	push	r19
 798:	4f 93       	push	r20
 79a:	5f 93       	push	r21
 79c:	6f 93       	push	r22
 79e:	7f 93       	push	r23
 7a0:	8f 93       	push	r24
 7a2:	9f 93       	push	r25
 7a4:	af 93       	push	r26
 7a6:	bf 93       	push	r27
 7a8:	ef 93       	push	r30
 7aa:	ff 93       	push	r31
 7ac:	e0 91 12 01 	lds	r30, 0x0112	; 0x800112 <intFunc+0x2>
 7b0:	f0 91 13 01 	lds	r31, 0x0113	; 0x800113 <intFunc+0x3>
 7b4:	09 95       	icall
 7b6:	ff 91       	pop	r31
 7b8:	ef 91       	pop	r30
 7ba:	bf 91       	pop	r27
 7bc:	af 91       	pop	r26
 7be:	9f 91       	pop	r25
 7c0:	8f 91       	pop	r24
 7c2:	7f 91       	pop	r23
 7c4:	6f 91       	pop	r22
 7c6:	5f 91       	pop	r21
 7c8:	4f 91       	pop	r20
 7ca:	3f 91       	pop	r19
 7cc:	2f 91       	pop	r18
 7ce:	0f 90       	pop	r0
 7d0:	0f be       	out	0x3f, r0	; 63
 7d2:	0f 90       	pop	r0
 7d4:	1f 90       	pop	r1
 7d6:	18 95       	reti

000007d8 <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
 7d8:	1f 92       	push	r1
 7da:	0f 92       	push	r0
 7dc:	0f b6       	in	r0, 0x3f	; 63
 7de:	0f 92       	push	r0
 7e0:	11 24       	eor	r1, r1
 7e2:	2f 93       	push	r18
 7e4:	3f 93       	push	r19
 7e6:	8f 93       	push	r24
 7e8:	9f 93       	push	r25
 7ea:	af 93       	push	r26
 7ec:	bf 93       	push	r27
 7ee:	80 91 ea 01 	lds	r24, 0x01EA	; 0x8001ea <timer0_millis>
 7f2:	90 91 eb 01 	lds	r25, 0x01EB	; 0x8001eb <timer0_millis+0x1>
 7f6:	a0 91 ec 01 	lds	r26, 0x01EC	; 0x8001ec <timer0_millis+0x2>
 7fa:	b0 91 ed 01 	lds	r27, 0x01ED	; 0x8001ed <timer0_millis+0x3>
 7fe:	30 91 e9 01 	lds	r19, 0x01E9	; 0x8001e9 <timer0_fract>
 802:	23 e0       	ldi	r18, 0x03	; 3
 804:	23 0f       	add	r18, r19
 806:	2d 37       	cpi	r18, 0x7D	; 125
 808:	20 f4       	brcc	.+8      	; 0x812 <__DATA_REGION_LENGTH__+0x12>
 80a:	01 96       	adiw	r24, 0x01	; 1
 80c:	a1 1d       	adc	r26, r1
 80e:	b1 1d       	adc	r27, r1
 810:	05 c0       	rjmp	.+10     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
 812:	26 e8       	ldi	r18, 0x86	; 134
 814:	23 0f       	add	r18, r19
 816:	02 96       	adiw	r24, 0x02	; 2
 818:	a1 1d       	adc	r26, r1
 81a:	b1 1d       	adc	r27, r1
 81c:	20 93 e9 01 	sts	0x01E9, r18	; 0x8001e9 <timer0_fract>
 820:	80 93 ea 01 	sts	0x01EA, r24	; 0x8001ea <timer0_millis>
 824:	90 93 eb 01 	sts	0x01EB, r25	; 0x8001eb <timer0_millis+0x1>
 828:	a0 93 ec 01 	sts	0x01EC, r26	; 0x8001ec <timer0_millis+0x2>
 82c:	b0 93 ed 01 	sts	0x01ED, r27	; 0x8001ed <timer0_millis+0x3>
 830:	80 91 ee 01 	lds	r24, 0x01EE	; 0x8001ee <timer0_overflow_count>
 834:	90 91 ef 01 	lds	r25, 0x01EF	; 0x8001ef <timer0_overflow_count+0x1>
 838:	a0 91 f0 01 	lds	r26, 0x01F0	; 0x8001f0 <timer0_overflow_count+0x2>
 83c:	b0 91 f1 01 	lds	r27, 0x01F1	; 0x8001f1 <timer0_overflow_count+0x3>
 840:	01 96       	adiw	r24, 0x01	; 1
 842:	a1 1d       	adc	r26, r1
 844:	b1 1d       	adc	r27, r1
 846:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <timer0_overflow_count>
 84a:	90 93 ef 01 	sts	0x01EF, r25	; 0x8001ef <timer0_overflow_count+0x1>
 84e:	a0 93 f0 01 	sts	0x01F0, r26	; 0x8001f0 <timer0_overflow_count+0x2>
 852:	b0 93 f1 01 	sts	0x01F1, r27	; 0x8001f1 <timer0_overflow_count+0x3>
 856:	bf 91       	pop	r27
 858:	af 91       	pop	r26
 85a:	9f 91       	pop	r25
 85c:	8f 91       	pop	r24
 85e:	3f 91       	pop	r19
 860:	2f 91       	pop	r18
 862:	0f 90       	pop	r0
 864:	0f be       	out	0x3f, r0	; 63
 866:	0f 90       	pop	r0
 868:	1f 90       	pop	r1
 86a:	18 95       	reti

0000086c <millis>:
 86c:	2f b7       	in	r18, 0x3f	; 63
 86e:	f8 94       	cli
 870:	60 91 ea 01 	lds	r22, 0x01EA	; 0x8001ea <timer0_millis>
 874:	70 91 eb 01 	lds	r23, 0x01EB	; 0x8001eb <timer0_millis+0x1>
 878:	80 91 ec 01 	lds	r24, 0x01EC	; 0x8001ec <timer0_millis+0x2>
 87c:	90 91 ed 01 	lds	r25, 0x01ED	; 0x8001ed <timer0_millis+0x3>
 880:	2f bf       	out	0x3f, r18	; 63
 882:	08 95       	ret

00000884 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 884:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 886:	84 b5       	in	r24, 0x24	; 36
 888:	82 60       	ori	r24, 0x02	; 2
 88a:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 88c:	84 b5       	in	r24, 0x24	; 36
 88e:	81 60       	ori	r24, 0x01	; 1
 890:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 892:	85 b5       	in	r24, 0x25	; 37
 894:	82 60       	ori	r24, 0x02	; 2
 896:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 898:	85 b5       	in	r24, 0x25	; 37
 89a:	81 60       	ori	r24, 0x01	; 1
 89c:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 89e:	ee e6       	ldi	r30, 0x6E	; 110
 8a0:	f0 e0       	ldi	r31, 0x00	; 0
 8a2:	80 81       	ld	r24, Z
 8a4:	81 60       	ori	r24, 0x01	; 1
 8a6:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 8a8:	e1 e8       	ldi	r30, 0x81	; 129
 8aa:	f0 e0       	ldi	r31, 0x00	; 0
 8ac:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 8ae:	80 81       	ld	r24, Z
 8b0:	82 60       	ori	r24, 0x02	; 2
 8b2:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 8b4:	80 81       	ld	r24, Z
 8b6:	81 60       	ori	r24, 0x01	; 1
 8b8:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 8ba:	e0 e8       	ldi	r30, 0x80	; 128
 8bc:	f0 e0       	ldi	r31, 0x00	; 0
 8be:	80 81       	ld	r24, Z
 8c0:	81 60       	ori	r24, 0x01	; 1
 8c2:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 8c4:	e1 eb       	ldi	r30, 0xB1	; 177
 8c6:	f0 e0       	ldi	r31, 0x00	; 0
 8c8:	80 81       	ld	r24, Z
 8ca:	84 60       	ori	r24, 0x04	; 4
 8cc:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 8ce:	e0 eb       	ldi	r30, 0xB0	; 176
 8d0:	f0 e0       	ldi	r31, 0x00	; 0
 8d2:	80 81       	ld	r24, Z
 8d4:	81 60       	ori	r24, 0x01	; 1
 8d6:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 8d8:	ea e7       	ldi	r30, 0x7A	; 122
 8da:	f0 e0       	ldi	r31, 0x00	; 0
 8dc:	80 81       	ld	r24, Z
 8de:	84 60       	ori	r24, 0x04	; 4
 8e0:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
 8e2:	80 81       	ld	r24, Z
 8e4:	82 60       	ori	r24, 0x02	; 2
 8e6:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
 8e8:	80 81       	ld	r24, Z
 8ea:	81 60       	ori	r24, 0x01	; 1
 8ec:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 8ee:	80 81       	ld	r24, Z
 8f0:	80 68       	ori	r24, 0x80	; 128
 8f2:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 8f4:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
 8f8:	08 95       	ret

000008fa <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 8fa:	83 30       	cpi	r24, 0x03	; 3
 8fc:	81 f0       	breq	.+32     	; 0x91e <__stack+0x1f>
 8fe:	28 f4       	brcc	.+10     	; 0x90a <__stack+0xb>
 900:	81 30       	cpi	r24, 0x01	; 1
 902:	99 f0       	breq	.+38     	; 0x92a <__stack+0x2b>
 904:	82 30       	cpi	r24, 0x02	; 2
 906:	a1 f0       	breq	.+40     	; 0x930 <__stack+0x31>
 908:	08 95       	ret
 90a:	87 30       	cpi	r24, 0x07	; 7
 90c:	a9 f0       	breq	.+42     	; 0x938 <__stack+0x39>
 90e:	88 30       	cpi	r24, 0x08	; 8
 910:	b9 f0       	breq	.+46     	; 0x940 <__stack+0x41>
 912:	84 30       	cpi	r24, 0x04	; 4
 914:	d1 f4       	brne	.+52     	; 0x94a <__stack+0x4b>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 916:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
 91a:	8f 7d       	andi	r24, 0xDF	; 223
 91c:	03 c0       	rjmp	.+6      	; 0x924 <__stack+0x25>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 91e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
 922:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 924:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
 928:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 92a:	84 b5       	in	r24, 0x24	; 36
 92c:	8f 77       	andi	r24, 0x7F	; 127
 92e:	02 c0       	rjmp	.+4      	; 0x934 <__stack+0x35>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 930:	84 b5       	in	r24, 0x24	; 36
 932:	8f 7d       	andi	r24, 0xDF	; 223
 934:	84 bd       	out	0x24, r24	; 36
 936:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 938:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f80b0>
 93c:	8f 77       	andi	r24, 0x7F	; 127
 93e:	03 c0       	rjmp	.+6      	; 0x946 <__stack+0x47>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 940:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f80b0>
 944:	8f 7d       	andi	r24, 0xDF	; 223
 946:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f80b0>
 94a:	08 95       	ret

0000094c <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 94c:	cf 93       	push	r28
 94e:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
 950:	90 e0       	ldi	r25, 0x00	; 0
 952:	fc 01       	movw	r30, r24
 954:	e4 58       	subi	r30, 0x84	; 132
 956:	ff 4f       	sbci	r31, 0xFF	; 255
 958:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 95a:	fc 01       	movw	r30, r24
 95c:	e0 57       	subi	r30, 0x70	; 112
 95e:	ff 4f       	sbci	r31, 0xFF	; 255
 960:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 962:	88 23       	and	r24, r24
 964:	61 f1       	breq	.+88     	; 0x9be <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 966:	90 e0       	ldi	r25, 0x00	; 0
 968:	88 0f       	add	r24, r24
 96a:	99 1f       	adc	r25, r25
 96c:	fc 01       	movw	r30, r24
 96e:	e8 54       	subi	r30, 0x48	; 72
 970:	ff 4f       	sbci	r31, 0xFF	; 255
 972:	c5 91       	lpm	r28, Z+
 974:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
 976:	fc 01       	movw	r30, r24
 978:	e2 55       	subi	r30, 0x52	; 82
 97a:	ff 4f       	sbci	r31, 0xFF	; 255
 97c:	a5 91       	lpm	r26, Z+
 97e:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
 980:	61 11       	cpse	r22, r1
 982:	09 c0       	rjmp	.+18     	; 0x996 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
 984:	9f b7       	in	r25, 0x3f	; 63
                cli();
 986:	f8 94       	cli
		*reg &= ~bit;
 988:	88 81       	ld	r24, Y
 98a:	20 95       	com	r18
 98c:	82 23       	and	r24, r18
 98e:	88 83       	st	Y, r24
		*out &= ~bit;
 990:	ec 91       	ld	r30, X
 992:	2e 23       	and	r18, r30
 994:	0b c0       	rjmp	.+22     	; 0x9ac <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
 996:	62 30       	cpi	r22, 0x02	; 2
 998:	61 f4       	brne	.+24     	; 0x9b2 <pinMode+0x66>
		uint8_t oldSREG = SREG;
 99a:	9f b7       	in	r25, 0x3f	; 63
                cli();
 99c:	f8 94       	cli
		*reg &= ~bit;
 99e:	88 81       	ld	r24, Y
 9a0:	32 2f       	mov	r19, r18
 9a2:	30 95       	com	r19
 9a4:	83 23       	and	r24, r19
 9a6:	88 83       	st	Y, r24
		*out |= bit;
 9a8:	ec 91       	ld	r30, X
 9aa:	2e 2b       	or	r18, r30
 9ac:	2c 93       	st	X, r18
		SREG = oldSREG;
 9ae:	9f bf       	out	0x3f, r25	; 63
 9b0:	06 c0       	rjmp	.+12     	; 0x9be <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
 9b2:	8f b7       	in	r24, 0x3f	; 63
                cli();
 9b4:	f8 94       	cli
		*reg |= bit;
 9b6:	e8 81       	ld	r30, Y
 9b8:	2e 2b       	or	r18, r30
 9ba:	28 83       	st	Y, r18
		SREG = oldSREG;
 9bc:	8f bf       	out	0x3f, r24	; 63
	}
}
 9be:	df 91       	pop	r29
 9c0:	cf 91       	pop	r28
 9c2:	08 95       	ret

000009c4 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
 9c4:	1f 93       	push	r17
 9c6:	cf 93       	push	r28
 9c8:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
 9ca:	28 2f       	mov	r18, r24
 9cc:	30 e0       	ldi	r19, 0x00	; 0
 9ce:	f9 01       	movw	r30, r18
 9d0:	e8 59       	subi	r30, 0x98	; 152
 9d2:	ff 4f       	sbci	r31, 0xFF	; 255
 9d4:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
 9d6:	f9 01       	movw	r30, r18
 9d8:	e4 58       	subi	r30, 0x84	; 132
 9da:	ff 4f       	sbci	r31, 0xFF	; 255
 9dc:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
 9de:	f9 01       	movw	r30, r18
 9e0:	e0 57       	subi	r30, 0x70	; 112
 9e2:	ff 4f       	sbci	r31, 0xFF	; 255
 9e4:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 9e6:	cc 23       	and	r28, r28
 9e8:	c1 f0       	breq	.+48     	; 0xa1a <digitalWrite+0x56>
 9ea:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 9ec:	81 11       	cpse	r24, r1
 9ee:	0e 94 7d 04 	call	0x8fa	; 0x8fa <turnOffPWM>

	out = portOutputRegister(port);
 9f2:	ec 2f       	mov	r30, r28
 9f4:	f0 e0       	ldi	r31, 0x00	; 0
 9f6:	ee 0f       	add	r30, r30
 9f8:	ff 1f       	adc	r31, r31
 9fa:	e2 55       	subi	r30, 0x52	; 82
 9fc:	ff 4f       	sbci	r31, 0xFF	; 255
 9fe:	a5 91       	lpm	r26, Z+
 a00:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
 a02:	9f b7       	in	r25, 0x3f	; 63
	cli();
 a04:	f8 94       	cli

	if (val == LOW) {
 a06:	11 11       	cpse	r17, r1
 a08:	04 c0       	rjmp	.+8      	; 0xa12 <digitalWrite+0x4e>
		*out &= ~bit;
 a0a:	8c 91       	ld	r24, X
 a0c:	d0 95       	com	r29
 a0e:	d8 23       	and	r29, r24
 a10:	02 c0       	rjmp	.+4      	; 0xa16 <digitalWrite+0x52>
	} else {
		*out |= bit;
 a12:	ec 91       	ld	r30, X
 a14:	de 2b       	or	r29, r30
 a16:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
 a18:	9f bf       	out	0x3f, r25	; 63
}
 a1a:	df 91       	pop	r29
 a1c:	cf 91       	pop	r28
 a1e:	1f 91       	pop	r17
 a20:	08 95       	ret

00000a22 <digitalRead>:

int digitalRead(uint8_t pin)
{
 a22:	cf 93       	push	r28
 a24:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
 a26:	28 2f       	mov	r18, r24
 a28:	30 e0       	ldi	r19, 0x00	; 0
 a2a:	f9 01       	movw	r30, r18
 a2c:	e8 59       	subi	r30, 0x98	; 152
 a2e:	ff 4f       	sbci	r31, 0xFF	; 255
 a30:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
 a32:	f9 01       	movw	r30, r18
 a34:	e4 58       	subi	r30, 0x84	; 132
 a36:	ff 4f       	sbci	r31, 0xFF	; 255
 a38:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
 a3a:	f9 01       	movw	r30, r18
 a3c:	e0 57       	subi	r30, 0x70	; 112
 a3e:	ff 4f       	sbci	r31, 0xFF	; 255
 a40:	c4 91       	lpm	r28, Z

	if (port == NOT_A_PIN) return LOW;
 a42:	cc 23       	and	r28, r28
 a44:	91 f0       	breq	.+36     	; 0xa6a <digitalRead+0x48>

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 a46:	81 11       	cpse	r24, r1
 a48:	0e 94 7d 04 	call	0x8fa	; 0x8fa <turnOffPWM>

	if (*portInputRegister(port) & bit) return HIGH;
 a4c:	ec 2f       	mov	r30, r28
 a4e:	f0 e0       	ldi	r31, 0x00	; 0
 a50:	ee 0f       	add	r30, r30
 a52:	ff 1f       	adc	r31, r31
 a54:	ec 55       	subi	r30, 0x5C	; 92
 a56:	ff 4f       	sbci	r31, 0xFF	; 255
 a58:	a5 91       	lpm	r26, Z+
 a5a:	b4 91       	lpm	r27, Z
 a5c:	ec 91       	ld	r30, X
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
 a5e:	ed 23       	and	r30, r29
 a60:	81 e0       	ldi	r24, 0x01	; 1
 a62:	90 e0       	ldi	r25, 0x00	; 0
 a64:	21 f4       	brne	.+8      	; 0xa6e <digitalRead+0x4c>
 a66:	80 e0       	ldi	r24, 0x00	; 0
 a68:	02 c0       	rjmp	.+4      	; 0xa6e <digitalRead+0x4c>
 a6a:	80 e0       	ldi	r24, 0x00	; 0
 a6c:	90 e0       	ldi	r25, 0x00	; 0
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	if (*portInputRegister(port) & bit) return HIGH;
	return LOW;
}
 a6e:	df 91       	pop	r29
 a70:	cf 91       	pop	r28
 a72:	08 95       	ret

00000a74 <__tablejump2__>:
 a74:	ee 0f       	add	r30, r30
 a76:	ff 1f       	adc	r31, r31
 a78:	05 90       	lpm	r0, Z+
 a7a:	f4 91       	lpm	r31, Z
 a7c:	e0 2d       	mov	r30, r0
 a7e:	09 94       	ijmp

00000a80 <_exit>:
 a80:	f8 94       	cli

00000a82 <__stop_program>:
 a82:	ff cf       	rjmp	.-2      	; 0xa82 <__stop_program>
